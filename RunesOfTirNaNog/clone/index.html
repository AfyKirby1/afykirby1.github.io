<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini RPG - Condensed Clone</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #222; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            font-family: monospace;
            color: white;
        }
        #gameCanvas { 
            border: 2px solid #444; 
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="info">WASD to Move | Shift to Sprint | ESC to Pause</div>

    <script>
        // === GAME CONFIG ===
        const TILE_SIZE = 50;
        const WORLD_WIDTH = 100;
        const WORLD_HEIGHT = 100;
        const PLAYER_SPEED = 3;

        // === CANVAS SETUP ===
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // === GAME STATE ===
        const state = {
            paused: false,
            player: { 
                x: WORLD_WIDTH * TILE_SIZE / 2, 
                y: WORLD_HEIGHT * TILE_SIZE / 2,
                speed: PLAYER_SPEED,
                isSprinting: false
            },
            camera: { x: 0, y: 0 },
            keys: {},
            world: [],
            playerSprite: null
        };

        // === SPRITE LOADING ===
        function loadPlayerSprite() {
            const img = new Image();
            img.onload = () => {
                state.playerSprite = img;
                console.log('Player sprite loaded');
            };
            img.onerror = () => {
                console.log('Failed to load sprite, using fallback');
                state.playerSprite = null;
            };
            img.src = 'guy_1.png';
        }

        // === WORLD GENERATION ===
        function generateWorld() {
            state.world = [];
            for (let y = 0; y < WORLD_HEIGHT; y++) {
                state.world[y] = [];
                for (let x = 0; x < WORLD_WIDTH; x++) {
                    const rand = Math.random();
                    if (rand < 0.85) state.world[y][x] = 0; // Ground
                    else if (rand < 0.95) state.world[y][x] = 1; // Water
                    else state.world[y][x] = 2; // Wall
                }
            }
        }

        // === INPUT ===
        document.addEventListener('keydown', e => {
            state.keys[e.code] = true;
            if (e.code === 'Escape') state.paused = !state.paused;
        });
        document.addEventListener('keyup', e => state.keys[e.code] = false);

        // === UPDATE ===
        function update() {
            if (state.paused) return;

            // Check sprint state
            state.player.isSprinting = state.keys['ShiftLeft'] || state.keys['ShiftRight'];
            const currentSpeed = state.player.isSprinting ? state.player.speed * 2 : state.player.speed;

            // Movement
            let dx = 0, dy = 0;
            if (state.keys['KeyW'] || state.keys['ArrowUp']) dy -= currentSpeed;
            if (state.keys['KeyS'] || state.keys['ArrowDown']) dy += currentSpeed;
            if (state.keys['KeyA'] || state.keys['ArrowLeft']) dx -= currentSpeed;
            if (state.keys['KeyD'] || state.keys['ArrowRight']) dx += currentSpeed;

            // Update player position with collision
            const newX = state.player.x + dx;
            const newY = state.player.y + dy;
            const tileX = Math.floor(newX / TILE_SIZE);
            const tileY = Math.floor(newY / TILE_SIZE);

            if (tileY >= 0 && tileY < WORLD_HEIGHT && tileX >= 0 && tileX < WORLD_WIDTH) {
                if (state.world[tileY][tileX] !== 2) { // Not a wall
                    state.player.x = newX;
                    state.player.y = newY;
                }
            }

            // Update camera to follow player
            state.camera.x = state.player.x - canvas.width / 2;
            state.camera.y = state.player.y - canvas.height / 2;
        }

        // === RENDER ===
        function render() {
            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(-state.camera.x, -state.camera.y);

            // Render visible tiles only
            const startX = Math.floor(state.camera.x / TILE_SIZE);
            const startY = Math.floor(state.camera.y / TILE_SIZE);
            const endX = Math.ceil((state.camera.x + canvas.width) / TILE_SIZE);
            const endY = Math.ceil((state.camera.y + canvas.height) / TILE_SIZE);

            for (let y = Math.max(0, startY); y < Math.min(WORLD_HEIGHT, endY); y++) {
                for (let x = Math.max(0, startX); x < Math.min(WORLD_WIDTH, endX); x++) {
                    const tile = state.world[y][x];
                    ctx.fillStyle = tile === 0 ? '#4a7c59' : tile === 1 ? '#3a5f8f' : '#555';
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    ctx.strokeStyle = '#333';
                    ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }

            // Render player with sprite or fallback
            if (state.playerSprite) {
                // Smooth visual transition for sprinting
                const scale = state.player.isSprinting ? 1.1 : 1.0;
                const alpha = state.player.isSprinting ? 0.9 : 1.0;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(state.player.x, state.player.y);
                ctx.scale(scale, scale);
                ctx.drawImage(state.playerSprite, -16, -16, 32, 32);
                ctx.restore();
            } else {
                // Fallback colored rectangle
                ctx.fillStyle = state.player.isSprinting ? '#ff4444' : '#ff6b6b';
                ctx.fillRect(state.player.x - 16, state.player.y - 16, 32, 32);
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(state.player.x - 16, state.player.y - 16, 32, 32);
            }

            ctx.restore();

            // Pause overlay
            if (state.paused) {
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '48px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
            }
        }

        // === GAME LOOP ===
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // === START ===
        loadPlayerSprite();
        generateWorld();
        gameLoop();
        console.log('Mini RPG Clone - KISS version loaded!');
    </script>
</body>
</html>

